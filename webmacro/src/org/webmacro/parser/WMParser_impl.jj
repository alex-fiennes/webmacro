options { STATIC = false; } 

PARSER_BEGIN(WMParser_impl)

package org.webmacro.parser;

import java.util.*;
import java.io.*;
import org.webmacro.*;
import org.webmacro.engine.*;
import org.webmacro.directive.*;
import org.webmacro.directive.Directive;
import org.webmacro.directive.DirectiveBuilder;
import org.webmacro.directive.Directive.ArgDescriptor;
import org.webmacro.directive.Directive.Subdirective;

public class WMParser_impl {

  private Broker broker;

  public void setBroker(Broker b) {
    broker = b;
  }

  // Standalone test harness
  public static void main(String[] args) throws Exception {
    WM wm = new WM();
    Broker broker = wm.getBroker();
    WMParser_impl parser;

    if (args.length >= 1) 
      parser = new WMParser_impl(new FileInputStream(args[0]));
    else 
      parser = new WMParser_impl(System.in);

    parser.setBroker(broker);
    Builder bb = parser.WMDocument();
    Context context = null;
    String encoding = "UTF8"; // XXX: main, should be ok

    try {
       context = wm.getContext();
       Object names[] = { "prop" };
       context.setProperty(names, "Example property");
       Block b = (Block) bb.build(new BuildContext(broker,encoding));
       // TemplateDumper d = new TemplateDumper();
       // b.accept(d);
       System.out.println((String) b.evaluate(context));
    } catch (Exception e) {
       e.printStackTrace();
    }
  }     
  

  // JavaCC hack for doing lexical state transitions syntactically

  private void SetState(int state) {
    if (state != token_source.curLexState) {
      while (token.next != null) {
        Token t = token;
        while (t.next != null && t.next.next != null) {
          t = t.next;
        }

        token_source.backup(t.next.image.length());
        t.next = null; 
      };
      jj_ntk = -1;
      token_source.SwitchTo(state); 
    }
  }

  private static String SEMI_FEATURE = 
    "Use of semicolon to delimit property reference -- use $( ) instead";
  private static String DDOLLAR_FEATURE = 
    "Use of $$ to reference template property -- use single $ instead";

  // Warning routines
  private void warnDeprecated(String feature) {
    broker.getLog("parser").warning("Deprecated feature: " + feature);
  }
}

PARSER_END(WMParser_impl)

TOKEN_MGR_DECLS : {
  // Required by SetState
  void backup(int n) { input_stream.backup(n); }
}


/*
  
  This parser makes substantial (and nonstandard) use of JavaCC lexical
  states.  Because there are really two languages -- a free-form
  underlying document language, and the WebMacro language -- we only
  want to be parsing webmacro constructs when we know we're in a WM
  section.  However, since we have pluggable directives, the language
  state may change in context-sensitive ways, and we want to
  communicate this to the lexical analyzer as well.  We do this
  through the SetState method, which changes the lexical state AND
  pushes back any lookahead tokens onto the input stream.  It assumes that
  the backup function in the input stream works "as expected."  

  The state management is somewhat complicated, so be careful with it.  
  In particular, we don't maintain a lexical state stack, although some
  rules do this on their own.  Rules which change the state are marked.  

  The states are: 
  DEFAULT: This is where we start, and in this state, we only recognize
           the minimal number of characters to identify a transition into
           the WM state.  
  WM:      We are in this state when we are parsing a WM directive. 
  QS:      We are in this state when we are parsing a quoted string in
           an WM directive.  
  COMMENT: We are in this state when we are parsing a comment

  If there are any state dependencies, productions are tagged with comments
  indicating this.  
  "State: X" means that the rule expects to be in state X on entry and is 
  in state X on exit.  
  "State: X->Y" means that the rule expects to be in state X on entry and
  is in state Y on exit.  
  "State: preserved" means that there are not state dependencies.   

  This parser also uses some JAVACODE productions, to account for the fact
  that directives are pluggable.  Directives and directive arguments are 
  parsed with JAVACODE productions. 

 */


/* ***************** */
/* Token Definitions */
/* ***************** */

<*> TOKEN : {
  <#_ALPHA_CHAR: ["a"-"z", "A"-"Z"] >
| <#_NUM_CHAR:   ["0"-"9"] >
| <#_ALPHANUM_CHAR: [ "a"-"z", "A"-"Z", "0"-"9" ] >
| <#_IDENTIFIER_CHAR: [ "a"-"z", "A"-"Z", "0"-"9", "_" ] >
| <#_IDENTIFIER: <_ALPHA_CHAR> (<_IDENTIFIER_CHAR>)* >
| <#_NEWLINE:    ( "\r\n" | "\r" | "\n" ) >
| <#_WHITESPACE: ( " " | "\t" ) >
| <#_QCHAR:      ( "\\" (<_NEWLINE> | ~["a"-"z", "A"-"Z", "0"-"9"] ) ) >
| <#_RESTOFLINE: (~["\r", "\n"])* >
| <#_COMMENT:    "##" <_RESTOFLINE> >
}

<DEFAULT> TOKEN : {
  <STUFF:     ( ~["#", "$", "{", "}", "\\"] )+ >
| <BEGIN:     "#begin">
| <END:       "#end">
| <LBRACE:    "{">
| <RBRACE:    "}">
}

<WM> SKIP : {
  <<_COMMENT>>
}

<DEFAULT> TOKEN : {
  <POUNDPOUND: "##">
}

<COMMENT> TOKEN : {
  <RESTOFLINE: <_RESTOFLINE>>
| <COMMENT_ELSE: ~[]>
}

<DEFAULT, WM, QS> TOKEN : {
  <DOLLAR:    "$">
| <QCHAR:     <_QCHAR> >  
| <SLASH:     "\\">
}

<DEFAULT, WM> TOKEN : {
  <POUND:      "#">
}

<WM, QS> TOKEN : {
  <QUOTE:     "\""> 
}

<WM> TOKEN : {
  <NULL:      "null">
| <TRUE:      "true">
| <FALSE:     "false">
| <WS:        (<_WHITESPACE>)+ >
| <NEWLINE:   <_NEWLINE> >
| <LPAREN:    "(">
| <RPAREN:    ")">
| <LBRACKET:  "[">
| <RBRACKET:  "]">
| <DOT:       ".">
| <OP_LT:     "<">
| <OP_LE:     "<=">
| <OP_GT:     ">">
| <OP_GE:     ">=">
| <OP_EQ:     "==">
| <OP_SET:    "=">
| <OP_NE:     "!=" | "<>">
| <OP_PLUS:   "+">
| <OP_MINUS:  "-">
| <OP_MULT:   "*">
| <OP_DIV:    "/">
| <OP_AND:    "&&" | "AND">
| <OP_OR:     "||" | "OR">
| <OP_NOT:    "!"  | "NOT">
| <COMMA:     ",">
| <SEMI:      ";">
| <WORD:      <_IDENTIFIER> > 
| <NUMBER:    (<_NUM_CHAR>)+>
| <OTHER:     ( ~[] ) >
}

<QS> TOKEN : {
  <QS_TEXT:      (~["\"", "$", "\r", "\n", "\\"])+>
}


/* ********************* */
/* Lookahead Productions */
/* ********************* */

/* Used by JAVACODE productions to do lookahead.  
   All lookahead productions assume state WM */

// is the next thing a subdirective? 
JAVACODE
Subdirective lookahead_subdirective(Subdirective[] subdirectives) {
  int n=1;
  if (getToken(n).kind == WS)            ++n;
  if (getToken(n).kind == NEWLINE)       ++n;
  if (getToken(n).kind == WS)            ++n;
  if (getToken(n).kind == POUND
      && getToken(n+1).kind == WORD) {
    String word = getToken(n+1).image;
    for (int i=0; i<subdirectives.length; i++) 
      if (word.equals(subdirectives[i].name))
        return subdirectives[i];
  }
  return null;
} 

// is the next thing the specified keyword? 
JAVACODE
boolean lookahead_keyword(String keyword) {
  int n=1;
  if (getToken(n).kind == WS) 
    ++n;
  if (getToken(n).kind == WORD
      && getToken(n).image.equals(keyword))
    return true;
  else 
    return false;
}


/* ************************** */
/* Directive Argument Parsing */
/* ************************** */

/* All argument parsing productions assume state WM */

// parse_arg -- parses a directive argument and returns it.  If the 
// argument is optional and omitted, it returns null, otherwise will
// throw a parse exception

JAVACODE 
Object parse_arg(ArgDescriptor arg) {
  switch (arg.type) {
  case Directive.ArgType_CONDITION:
    return Conditional();
      
  case Directive.ArgType_BLOCK: {
    OptionalWsNl();
    SetState(DEFAULT);
    BlockBuilder b = Block();
    SetState(WM);
    OptionalWs();
    return b;
  }

  case Directive.ArgType_LITBLOCK: {
    OptionalWsNl();
    SetState(DEFAULT);
    BlockBuilder b = LiteralBlock();
    SetState(WM);
    OptionalWs();
    return b;
  }

  case Directive.ArgType_LVALUE:
    return LValue();

  case Directive.ArgType_RVALUE:
    return RValue();

  case Directive.ArgType_QUOTEDSTRING:
    return QuotedString();

  case Directive.ArgType_ASSIGN:
    Punct_EQ();     
    return "=";
    
  case Directive.ArgType_KEYWORD:
    if (arg.optional && !lookahead_keyword(arg.keyword)) 
      return null;
    else {
      Keyword(arg.keyword);
      return arg.keyword;
    }

  default:
    throw new ParseException("ParseDirectiveArg: Unknown argument type " 
                             + arg.type);
  };
}

// parse_arg_group -- parses a group of arguments.  If the group is optional, 
// it looks ahead for the group's starting keyword, returning false if the
// group is not seen.  

JAVACODE
boolean parse_arg_group(ArgDescriptor[] args, int i, 
                         DirectiveArgs da) 
  throws BuildException {
  if (args[i].optional) 
    if (!lookahead_keyword(args[args[i].children[0]].keyword))
      return false;
  for (int j=0; j<args[i].subordinateArgs; j++) {
    ArgDescriptor child = args[args[i].children[j]];
    if (child.type == Directive.ArgType_GROUP) {
      parse_arg_group(args, args[i].children[j], da);
    }
    else {
      Object o = parse_arg(child);
      da.setArg(child.id, o);
    }
  }
  return true;
}

//parse_args -- parse a whole directive's worth of arguments 

JAVACODE 
void parse_args(ArgDescriptor[] args, DirectiveArgs da) {
  try {
    for (int i=0; i < args.length; ) {
      ArgDescriptor arg = args[i];

      if (arg.type == Directive.ArgType_GROUP) 
        parse_arg_group(args, i, da);
      else if (arg.type == Directive.ArgType_CHOICE) {
        for (int j=0; j<arg.subordinateArgs; j++) {
          // Each child is a GROUP, so we want to look at child's first child
          ArgDescriptor child = args[arg.children[j]];
          if (lookahead_keyword(args[child.children[0]].keyword)) 
            parse_arg_group(args, arg.children[j], da);
        }
      }
      else {
        Object o = parse_arg(arg);
        da.setArg(arg.id, o);
      }
      i = arg.nextArg;
    }
  }
  catch (BuildException e) {
    throw new ParseException("BuildException", e);
  }
}


/* ***************** */
/* Directive Parsing */
/* ***************** */

/* Parses all of a directive's arguments.  Assumes state WM.  */

JAVACODE
DirectiveBuilder parse_directive(String directive) throws ParseException {
  DirectiveBuilder db=null;
  DirectiveDescriptor descriptor=null;
  Subdirective subd;

  try { 
    descriptor = 
      (DirectiveDescriptor) broker.get("org.webmacro.directive.Directive", 
                                       directive);
    if (!descriptor.valid) 
      throw new ParseException("Descriptor for directive " + directive
                               + " is not valid");
  }
  catch (Exception e) {
    throw new ParseException("Exception fetching directive "+directive
                             + System.getProperty("line.separator"), e); 
  }
  db = new DirectiveBuilder(descriptor);
  parse_args(descriptor.args, db);

  if (descriptor.subdirectives != null 
      && descriptor.subdirectives.length > 0) {
    DirectiveArgs da;

    while ((subd = lookahead_subdirective(descriptor.subdirectives)) != null) {
      SubdirectiveStart();
      try {
        da = db.newSubdirective(subd.id);
      } catch (BuildException e) {
        throw new ParseException("BuildException", e);
      };
      parse_args(subd.args, da);
    }
  }
  OptionalWs();
    
  return db;
}


/* Utility productions used by above JavaCode productions (State: WM) */

void OptionalWsNl() : {
}
{
  [ <WS> ] [ <NEWLINE> [ <WS> ] ]
}

void OptionalWs() : {
}
{
  [ <WS> ] 
}

void SubdirectiveStart() : {
}
{ 
  OptionalWsNl() <POUND> <WORD> [ <WS> ] 
}


/* Productions used by JavaCode productions to parse directive arguments. 
   Correpond mostly to the defined argument types.  (State: WM) */

Builder LValue() : {
  Builder lv;
}
{
  [ <WS> ] lv=VariableReference() [ <WS> ] { return lv; }
}

Object RValue() : {
  Object rv;
}
{
  [ <WS> ] rv=Expression() [ <WS> ] { return rv; }
}

void Punct_EQ() : {
  Token t;
}
{
  [ <WS> ] <OP_SET> [ <WS> ]
}

void Punct_COMMA() : {
  Token t;
}
{
  [ <WS> ] <COMMA> [ <WS> ]
}

void Punct_LPAREN() : {
  Token t;
}
{
  [ <WS> ] <LPAREN> [ <WS> ]
}

void Punct_RPAREN() : {
  Token t;
}
{
  [ <WS> ] <RPAREN> [ <WS> ]
}

void Keyword(String s) : {
  Token t;
}
{
  [ <WS> ] t=<WORD> [ <WS> ]
  { 
    if (!s.equals(t.image)) 
      throw new ParseException("Encountered " + t.image + " at line " 
                               + t.beginLine + "; expecting " + s);
  }
}

Object Conditional() : {
  Object e;
}
{
  <LPAREN> [ <WS> ] e=Expression() [ <WS> ] <RPAREN> { return e; }
}


/* ******************* */
/* Variable References */
/* ******************* */

/* Productions used in WM variable references.  State: WM.  */

// Used by VariableReference; shouldn't be used outside it
void VariableReferenceGuts(Vector v) : {
  Token t;
  Object element;
  ListBuilder argList;
}
{
  t=<WORD> { v.addElement(t.image); }
  ( <DOT> t=<WORD> { element = t.image; } 
    [ <LPAREN> argList=ArgList() <RPAREN> 
      { element = new PropertyMethodBuilder((String) element, argList); }
    ]  
    { v.addElement(element); }
  )*  
}

Builder VariableReference() : {
  Vector v = new Vector();
}
{
  <DOLLAR> 
  [ <DOLLAR> { warnDeprecated(DDOLLAR_FEATURE); } ] 
  (
    VariableReferenceGuts(v) [ <SEMI> { warnDeprecated(SEMI_FEATURE); } ] 
    | <LPAREN> VariableReferenceGuts(v) <RPAREN>
  )
  { 
    Object[] names = new Object[v.size()];
    v.copyInto(names);
    return new VariableBuilder(names, false);
  }
}


/* ********************** */
/* Expression Productions */
/* ********************** */

/* Productions used in parsing WM expressions.  State: WM.  
   Most general expression type is Expression() */

// State: preserved
Builder QuotedString() : {
  int entryState = token_source.curLexState;
  Token t;
  QuotedStringBuilder qs = new QuotedStringBuilder();
}
{
  <QUOTE> { SetState(QS); } 
  ( t=<QS_TEXT> { qs.addElement(t.image); }
    | t=<QCHAR> { qs.addElement(t.image.substring(1)); } 
    | t=<SLASH> { qs.addElement(t.image); }
    | LOOKAHEAD(<DOLLAR>) DollarReference(qs)
  ) * 
  <QUOTE> 
  { SetState(entryState); }
  { return qs; }
}

ListBuilder ArgList() : {
  ListBuilder list = new ListBuilder();
  Object e;
}
{
  [ e=Expression() [<WS>] { list.addElement(e); } 
    ( 
      <COMMA> [ <WS> ] e=Expression() [<WS>] { list.addElement(e); } 
    ) * 
  ] 
  { return list; }
}

ListBuilder BracketList() : {
  ListBuilder list;
}
{
  <LBRACKET> [<WS>] list=ArgList() <RBRACKET> 
  { return list; }
}


Object Term() : {
  Object e;
  Token t;
}
{
  ( 
    e=VariableReference() 
    | <LPAREN> e=Expression() <RPAREN>
    | e=QuotedString()
    | e=BracketList() 
    | <NULL>           { e = null; } 
    | <TRUE>           { e = Boolean.TRUE; } 
    | <FALSE>          { e = Boolean.FALSE; }
    | <OP_NOT> [<WS>] e=Term() { e = new Expression.NotBuilder(e); }
    | t=<NUMBER>           
      { try { e = new Long(t.image); } 
        catch (NumberFormatException ex) { e=null; } }
    | <OP_MINUS>t=<NUMBER> 
      { try { long l = Long.parseLong(t.image); e = new Long(-l); }
        catch (NumberFormatException ex) { e=null; } }
  ) 
  { return e; }
}

Object Factor() : {
  Object e1, e2=null;
  Token op=null;
}
{
  e1=Term() 
  [ LOOKAHEAD(2) [<WS>] (op=<OP_MULT> | op=<OP_DIV>) 
                 [<WS>] e2=Factor() ]
  { 
    if (op == null)
      return e1;
    else if (op.kind == OP_MULT) 
      return new Expression.MultiplyBuilder(e1, e2);
    else if (op.kind == OP_DIV) 
      return new Expression.DivideBuilder(e1, e2);
    else 
      throw new ParseException("internal parser error in Factor()");
  }
}

Object AExpression() : {
  Object e1, e2=null;
  Token op=null;
}
{
  e1=Factor() 
  [ LOOKAHEAD(2) [<WS>] (op=<OP_PLUS> | op=<OP_MINUS>) 
                 [<WS>] e2=AExpression() ] 
  { 
    if (op == null)
      return e1;
    else if (op.kind == OP_PLUS) 
      return new Expression.AddBuilder(e1, e2);
    else if (op.kind == OP_MINUS) 
      return new Expression.SubtractBuilder(e1, e2);
    else 
      throw new ParseException("internal parser error in AExpression()");
  }
}

Token RelOp() : { 
  Token t;
}
{
  ( t=<OP_EQ> | t=<OP_SET> | t=<OP_NE> 
    | t=<OP_GT> | t=<OP_GE> | t=<OP_LE> | t=<OP_LT> )
  { return t; }
}

Object CExpression() : {
  // Note that CExpression is a little different from other binary
  // expression rules, as we don't want to accept a == b == c
  // Thanks to Aldona Majorek for pointing this out

  Object e1, e2=null;
  Token op=null;
}
{
  e1=AExpression() 
  [ LOOKAHEAD(2) [<WS>] op=RelOp() [<WS>] e2=AExpression() ]
  { 
    if (op == null) 
      return e1;
    else switch (op.kind) {
      case OP_EQ:  return new Expression.CompareEqBuilder(e1, e2);
      case OP_SET: return new Expression.CompareEqBuilder(e1, e2);
      case OP_NE:  return new Expression.CompareNeBuilder(e1, e2);
      case OP_GT:  return new Expression.CompareGtBuilder(e1, e2);
      case OP_GE:  return new Expression.CompareGeBuilder(e1, e2);
      case OP_LE:  return new Expression.CompareLeBuilder(e1, e2);
      case OP_LT:  return new Expression.CompareLtBuilder(e1, e2);
      default:   
        throw new ParseException("internal parser error in CExpression()");
    }
  } 
}

Object AndExpression() : {
  Object e1, e2=null;
}
{
  e1=CExpression() 
  [ LOOKAHEAD(2) [<WS>] <OP_AND> [<WS>] e2=AndExpression() ]
  { 
    if (e2 == null) 
      return e1;
    else 
      return new Expression.AndBuilder(e1, e2);
  }
}

Object OrExpression() : {
  Object e1, e2=null;
}
{
  e1=AndExpression() 
  [ LOOKAHEAD(2) [<WS>] <OP_OR> [<WS>] e2=OrExpression() ]
  { 
    if (e2 == null) 
      return e1;
    else 
      return new Expression.OrBuilder(e1, e2);
  }
}

Object Expression() : {
  Object e=null;
}
{ 
  e=OrExpression() { return e; }
}


/* ********************** */
/* WM Content Productions */
/* ********************** */

/* All of the following operate in the DEFAULT state */

// Parses an entire directive.  Treats # as text if the previous character
// is a letter, digit, or certain special characters (=, ', ")
void Directive(ParserBlockBuilder b) : {
  Token t;
  Object o;
}
{
  <POUND>
  { SetState(WM); } 
  ( LOOKAHEAD(<WORD>, { b.directiveOk() } ) 
       t=<WORD> [ <WS> ] o=parse_directive(t.image) 
       { b.eatTrailingWsNl(); b.addElement(o); }
    | { b.addElement("#"); }
  ) 
  { SetState(DEFAULT); }
}

// Parses an entire directive.  Treats ## as text if the previous character
// is a letter, digit, or certain special characters (=, ', ")
void Comment(ParserBlockBuilder b) : {
}
{
  <POUNDPOUND>
  { SetState(COMMENT); } 
  ( LOOKAHEAD( { b.directiveOk() } ) 
      [ <RESTOFLINE> ] { b.eatTrailingWsNl(); }
    | { b.addElement("##"); }
  ) 
  { SetState(DEFAULT); }
}

void DollarReference(Vector v) : {
  int entryState = token_source.curLexState;
  Object o;
}
{
  { SetState(WM); }
  ( LOOKAHEAD(<DOLLAR> [ <DOLLAR> ] [ <LPAREN> ] <WORD>)
      o=VariableReference() { v.addElement(o); }
    | <DOLLAR> { v.addElement("$"); }
  )
  { SetState(entryState); }
}

void WMContent(ParserBlockBuilder b) : {
  Token t;
  Object o;
}
{
  ( t=<STUFF>       { b.addElement(t.image); }
    | t=<QCHAR>     { b.addElement(t.image.substring(1)); b.markLiteral(); }
    | t=<SLASH>     { b.addElement(t.image); }
    | Directive(b) 
    | Comment(b)
    | LOOKAHEAD(<DOLLAR>) DollarReference(b)
  ) 
}

void LiteralWMContent(ParserBlockBuilder b) : {
  Token t;
}
{
  ( 
    t=<QCHAR> { b.addElement(t.image.substring(1)); }
    | ( t=<STUFF> | t=<SLASH> | t=<POUND> | t=<DOLLAR> | t=<POUNDPOUND> )
      { b.addElement(t.image); }
  )
}

BlockBuilder LiteralBlock() : {
  ParserBlockBuilder block = new ParserBlockBuilder();
  Token t;
}
{
  ( 
    LOOKAHEAD(<LBRACE>) 
    ( <LBRACE>    
      ( LiteralWMContent(block) 
        | ( t=<BEGIN> | t=<END> )     { block.addElement(t.image); }
      ) * 
      <RBRACE> )
  | ( [ <BEGIN> ] 
      ( LiteralWMContent(block)
        | ( t=<LBRACE> | t=<RBRACE> ) { block.addElement(t.image); } 
      ) * 
      <END> )
  )
  { return block; }
}

BlockBuilder Block() : {
  ParserBlockBuilder block = new ParserBlockBuilder();
  Token t;
}
{ 
  ( 
    LOOKAHEAD(<LBRACE>) 
    ( <LBRACE> 
      ( WMContent(block) 
        | (t=<BEGIN> | t=<END>)     { block.addElement(t.image); }
      ) * <RBRACE> { block.eatTrailingWs(); } )
  | ( [ <BEGIN> ] 
      ( WMContent(block) 
        | (t=<LBRACE> | t=<RBRACE>) { block.addElement(t.image); }
      ) * <END> { block.eatTrailingWs(); } )
  )
  { return block; }
}

BlockBuilder WMDocument() : {
  ParserBlockBuilder block = new ParserBlockBuilder();
  Token t;
}
{
  ( 
    ( WMContent(block)
      | (t=<BEGIN> | t=<END> | t=<LBRACE> | t=<RBRACE>)
        { block.addElement(t.image); }
    )
  ) * <EOF> 
  { return block; }
}

