options { STATIC = false; } 

PARSER_BEGIN(WMParser_impl)

package org.webmacro.parser;

import java.util.*;
import org.webmacro.*;
import org.webmacro.engine.*;
import org.webmacro.directive.*;
import org.webmacro.directive.Directive;
import org.webmacro.directive.DirectiveBuilder;
import org.webmacro.directive.Directive.ArgDescriptor;
import org.webmacro.directive.Directive.Subdirective;

public class WMParser_impl {

  private Broker broker;

  public void setBroker(Broker b) {
    broker = b;
  }

  public static void main(String[] args) throws Exception {
    WM wm = new WM();
    Broker broker = wm.getBroker();

    WMParser_impl parser = new WMParser_impl(System.in);
    parser.setBroker(broker);
    Builder bb = parser.WMDocument();
    Context context = null;
    String encoding = "UTF8"; // XXX: main, should be ok

    try {
       context = wm.getContext();
       Object names[] = { "prop" };
       context.setProperty(names, "Example property");
       Block b = (Block) bb.build(new BuildContext(broker,encoding));
       // Dumper d = new Dumper();
       // b.accept(d);
       System.out.println((String) b.evaluate(context));
    } catch (Exception e) {
       e.printStackTrace();
    }
  }     
  
  void SetState(int state) {
    while (token.next != null) {
      Token t = token;
      while (t.next != null && t.next.next != null) {
        t = t.next;
      }

      token_source.backup(t.next.image.length());
      t.next = null; 
    };
    jj_ntk = -1;
    token_source.SwitchTo(state); 
  }
}

PARSER_END(WMParser_impl)

TOKEN_MGR_DECLS : {
  void backup(int n) { input_stream.backup(n); }
}


/*
  
  This parser makes substantial (and nonstandard) use of JavaCC lexical
  states.  Because there are really two languages -- a free-form
  underlying document language, and the WebMacro language -- we only
  want to be parsing webmacro constructs when we know we're in a WM
  section.  However, since we have pluggable directives, the language
  state may change in context-sensitive ways, and we want to
  communicate this to the lexical analyzer as well.  We do this
  through the SetState method, which changes the lexical state AND
  pushes back any lookahead tokens onto the input stream.  It assumes that
  the backup function in the input stream works "as expected."  

  The state management is somewhat complicated, so be careful with it.  
  In particular, we don't maintain a lexical state stack, although some
  rules do this on their own.  Rules which change the state are marked.  

  The states are: 
  DEFAULT: This is where we start, and in this state, we only recognize
           the minimal number of characters to identify a transition into
           the WM state.  
  WM:      We are in this state when we are parsing a WM directive. 
  QS:      We are in this state when we are parsing a quoted string in
           an WM directive.  
 
 */

<*> TOKEN : {
  <#_ALPHA_CHAR: ["a"-"z", "A"-"Z"] >
| <#_NUM_CHAR:   ["0"-"9"] >
| <#_ALPHANUM_CHAR: [ "a"-"z", "A"-"Z", "0"-"9" ] >
| <#_IDENTIFIER_CHAR: [ "a"-"z", "A"-"Z", "0"-"9", "_" ] >
| <#_IDENTIFIER: <_ALPHA_CHAR> (<_IDENTIFIER_CHAR>)* >
| <#_NEWLINE:    ( "\r\n" | "\r" | "\n" ) >
| <#_WHITESPACE: ( " " | "\t" ) >
| <#_QCHAR:      ( "\\" (<_NEWLINE> | ~["a"-"z", "A"-"Z", "0"-"9"] ) ) >
| <#_COMMENT:    "##" (~["\r", "\n"])* >
}

<DEFAULT> TOKEN : {
  <STUFF:     ( ~["#", "$", "{", "}", "\\"] )+ >
| <BEGIN:     "#begin">
| <END:       "#end">
| <LBRACE:    "{">
| <RBRACE:    "}">
}

<WM> SKIP : {
  <<_COMMENT>>
}

<DEFAULT> TOKEN : {
  <COMMENT:   <_COMMENT>>
}

<DEFAULT, WM, QS> TOKEN : {
  <DOLLAR:    "$">
| <QCHAR:     <_QCHAR> >  
| <SLASH:     "\\">
}

<DEFAULT, WM> TOKEN : {
  <POUND:     "#">
}

<WM, QS> TOKEN : {
  <QUOTE:     "\""> 
}

<WM> TOKEN : {
  <NULL:      "null">
| <TRUE:      "true">
| <FALSE:     "false">
| <WORD:      <_IDENTIFIER> > 
| <WS:        (<_WHITESPACE>)+ >
| <NEWLINE:   <_NEWLINE> >
| <LPAREN:    "(">
| <RPAREN:    ")">
| <LBRACKET:  "[">
| <RBRACKET:  "]">
| <DOT:       ".">
| <OP_LT:     "<">
| <OP_LE:     "<=">
| <OP_GT:     ">">
| <OP_GE:     ">=">
| <OP_EQ:     "==">
| <OP_SET:    "=">
| <OP_NE:     "!=">
| <OP_PLUS:   "+">
| <OP_MINUS:  "-">
| <OP_MULT:   "*">
| <OP_DIV:    "/">
| <OP_AND:    "&&">
| <OP_OR:     "||">
| <OP_NOT:    "!">
| <COMMA:     ",">
| <NUMBER:    (<_NUM_CHAR>)+>
| <OTHER:     ( ~[] ) >
}

<QS> TOKEN : {
  <QS_TEXT:      (~["\"", "$", "\r", "\n", "\\"])+>
}

/* 
 
  This parser also uses some JAVACODE productions, to account for the fact
  that directives are pluggable.  Directives and directive arguments are 
  parsed with these JAVACODE productions. 

 */


// Lookahead productions

// is the next thing a subdirective? 
JAVACODE
Subdirective 
lookahead_subdirective(Subdirective[] subdirectives) {
  int n=1;
  if (getToken(n).kind == WS)            ++n;
  if (getToken(n).kind == NEWLINE)       ++n;
  if (getToken(n).kind == WS)            ++n;
  if (getToken(n).kind == POUND
      && getToken(n+1).kind == WORD) {
    String word = getToken(n+1).image;
    for (int i=0; i<subdirectives.length; i++) 
      if (word.equals(subdirectives[i].name))
        return subdirectives[i];
  }
  return null;
} 

// is the next thing the specified keyword? 
JAVACODE
boolean 
lookahead_keyword(String keyword) {
  int n=1;
  if (getToken(n).kind == WS)
    ++n;
  if (getToken(n+1).kind == WORD
      && getToken(n+1).image.equals(keyword))
    return true;
  else 
    return false;
}


//parse_arg -- parses a directive argument and returns it.  If the 
// argument is optional and omitted, it returns null, otherwise will
// throw a parse exception
//State information: expects WM, returns in WM
JAVACODE
Object parse_arg(ArgDescriptor arg) {
  switch (arg.type) {
  case Directive.ArgType_CONDITION:
    return Conditional();
      
  case Directive.ArgType_BLOCK: {
    OptionalWsNl();
    SetState(DEFAULT);
    BlockBuilder b = Block();
    SetState(WM);
    OptionalWs();
    return b;
  }

  case Directive.ArgType_LITBLOCK: {
    OptionalWsNl();
    SetState(DEFAULT);
    BlockBuilder b = LiteralBlock();
    SetState(WM);
    OptionalWs();
    return b;
  }

  case Directive.ArgType_LVALUE:
    return LValue();

  case Directive.ArgType_RVALUE:
    return RValue();

  case Directive.ArgType_PUNCT:
    switch (arg.punctId) {
    case Directive.Punct_COMMA:  Punct_COMMA();  return ",";
    case Directive.Punct_EQUALS: Punct_EQ();     return "=";
    case Directive.Punct_LPAREN: Punct_LPAREN(); return "(";
    case Directive.Punct_RPAREN: Punct_RPAREN(); return ")";
    }
    return null;
    
  case Directive.ArgType_KEYWORD:
    if (arg.optional && !lookahead_keyword(arg.keyword)) 
      return null;
    else {
      Keyword(arg.keyword);
      return arg.keyword;
    }
  };

  return null;
}

//parse_group -- parses a group of arguments.  If the group is optional, 
// it looks ahead for the group's starting keyword, returning false if the
// group is not seen.  
JAVACODE
boolean parse_group(ArgDescriptor[] args, int i, 
                    DirectiveArgs da) 
  throws BuildException {
  if (args[i].optional) 
    if (!lookahead_keyword(args[i+1].keyword))
      return false;
  for (int j=0; j<args[i].subordinateArgs; j++) {
    Object o = parse_arg(args[i+1+j]);
    da.setArg(args[i+1+j].id, o);
  }
  return true;
}


//parse_args -- parse a whole directive's worth of arguments 
//State information -- expects WM, returns WM
JAVACODE 
void parse_args(ArgDescriptor[] args, DirectiveArgs da) {
  try {
    for (int i=0; i < args.length; ) {
      ArgDescriptor arg = args[i];

      if (arg.type == Directive.ArgType_GROUP) {
        boolean parsed = parse_group(args, i, da);
        if (!parsed || !arg.repeating)
          i += 1 + arg.subordinateArgs;
      }
      else if (arg.type == Directive.ArgType_CHOICE) {
      }
      else {
        Object o = parse_arg(arg);
        da.setArg(arg.id, o);
        ++i;
      }
    }
  }
  catch (BuildException e) {
    throw new ParseException("BuildException");
  }
}


// State information: On entry, expect WM; on exit, DEFAULT
JAVACODE
DirectiveBuilder parse_directive(String directive) throws ParseException {
  DirectiveBuilder db=null;
  DirectiveDescriptor descriptor=null;
  Subdirective subd;

  try { 
    descriptor = 
      (DirectiveDescriptor) broker.get("org.webmacro.directive.Directive", 
                                       directive);
    if (!descriptor.valid) 
      throw new ParseException("Descriptor for directive " + directive
                               + " is not valid");
  }
  catch (Exception e) {
    throw new ParseException("Exception fetching directive "+directive
                             + System.getProperty("line.separator") 
                             + e.toString());
    // @@@ Maybe backfit ParseException to be rethrowable
  }
  db = new DirectiveBuilder(descriptor);
  parse_args(descriptor.args, db);

  if (descriptor.subdirectives != null 
      && descriptor.subdirectives.length > 0) {
    DirectiveArgs da;

    while ((subd = lookahead_subdirective(descriptor.subdirectives)) != null) {
      SubdirectiveStart();
      try {
        da = db.newSubdirective(subd.id);
      } catch (BuildException e) {
        throw new ParseException("BuildException");
      };
      parse_args(subd.args, da);
    }
  }
  OptionalWs();
    
  SetState(DEFAULT);
  return db;
}

Token RelOp() : { 
  Token t;
}
{
  ( t=<OP_EQ> | t=<OP_NE> | t=<OP_GT> | t=<OP_GE> | t=<OP_LE> | t=<OP_LT> )
  { return t; }
}

void OptionalWsNl() : {
}
{
  [ <WS> ] [ <NEWLINE> [ <WS> ] ]
}

void OptionalWs() : {
}
{
  [ <WS> ] 
}

Builder LValue() : {
  Builder lv;
}
{
  [ <WS> ] lv=VariableReference() [ <WS> ] { return lv; }
}

Object RValue() : {
  Object rv;
}
{
  [ <WS> ] rv=Expression() [ <WS> ] { return rv; }
}

void Punct_EQ() : {
  Token t;
}
{
  [ <WS> ] <OP_SET> [ <WS> ]
}

void Punct_COMMA() : {
  Token t;
}
{
  [ <WS> ] <COMMA> [ <WS> ]
}

void Punct_LPAREN() : {
  Token t;
}
{
  [ <WS> ] <LPAREN> [ <WS> ]
}

void Punct_RPAREN() : {
  Token t;
}
{
  [ <WS> ] <RPAREN> [ <WS> ]
}

void Keyword(String s) : {
  Token t;
}
{
  [ <WS> ] t=<WORD> [ <WS> ]
  { 
    if (!s.equals(t.image)) 
      throw new ParseException("Encountered " + t.image + " at line " 
                               + t.beginLine + "; expecting " + s);
  }
}

Object Conditional() : {
  Object e;
}
{
  <LPAREN> [ <WS> ] e=Expression() [ <WS> ] <RPAREN> { return e; }
}


void VariableReferenceGuts(Vector v) : {
  Token t;
  Object element;
  ListBuilder argList;
}
{
  t=<WORD> { v.addElement(t.image); }
  ( <DOT> t=<WORD> { element = t.image; } 
    [ <LPAREN> argList=ArgList() <RPAREN> 
      { element = new PropertyMethodBuilder((String) element, argList); }
    ]  
    { v.addElement(element); }
  )*  
}

// State information: Expects WM
Builder VariableReference() : {
  Vector v = new Vector();
}
{
  <DOLLAR> (
    VariableReferenceGuts(v) 
    | <LPAREN> VariableReferenceGuts(v) <RPAREN>
  )
  { 
    Object[] names = new Object[v.size()];
    v.copyInto(names);
    return new VariableBuilder(names, false);
  }
}

// State information: state is preserved
Builder QuotedString() : {
  int entryState = token_source.curLexState;
  Token t;
  QuotedStringBuilder qs = new QuotedStringBuilder();
  Builder b, term;
}
{
  <QUOTE> { SetState(QS); } 
  ( t=<QS_TEXT> { qs.addElement(t.image); }
    | t=<QCHAR> { qs.addElement(t.image.substring(1)); } 
    | t=<SLASH> { qs.addElement(t.image); }
    | LOOKAHEAD(<DOLLAR>) { SetState(WM); } 
      term=VariableReference() { qs.addElement(term); } 
      { SetState(QS); } ) * 
  <QUOTE> 
  { SetState(entryState); }
  { return qs; }
}


ListBuilder BracketList() : {
  ListBuilder list;
}
{
  <LBRACKET> [<WS>] list=ArgList() <RBRACKET> 
  { return list; }
}


ListBuilder ArgList() : {
  ListBuilder list = new ListBuilder();
  Object e;
}
{
  [ e=Expression() [<WS>] { list.addElement(e); } 
    ( 
      <COMMA> [ <WS> ] e=Expression() [<WS>] { list.addElement(e); } 
    ) * 
  ] 
  { return list; }
}

Object Factor() : {
  Object e1, e2=null;
  Token op=null;
}
{
  e1=Term() 
  [ LOOKAHEAD(2) [<WS>] (op=<OP_MULT> | op=<OP_DIV>) 
                 [<WS>] e2=Factor() ]
  { 
    if (op == null)
      return e1;
    else if (op.kind == OP_MULT) 
      return new Expression.MultiplyBuilder(e1, e2);
    else if (op.kind == OP_DIV) 
      return new Expression.DivideBuilder(e1, e2);
    else 
      throw new ParseException("internal parser error in Factor()");
  }
}

Object AExpression() : {
  Object e1, e2=null;
  Token op=null;
}
{
  e1=Factor() 
  [ LOOKAHEAD(2) [<WS>] (op=<OP_PLUS> | op=<OP_MINUS>) 
                 [<WS>] e2=AExpression() ] 
  { 
    if (op == null)
      return e1;
    else if (op.kind == OP_PLUS) 
      return new Expression.AddBuilder(e1, e2);
    else if (op.kind == OP_MINUS) 
      return new Expression.SubtractBuilder(e1, e2);
    else 
      throw new ParseException("internal parser error in AExpression()");
  }
}

Object CExpression() : {
  Object e1, e2=null;
  Token op=null;
}
{
  e1=AExpression() 
  [ LOOKAHEAD(2) [<WS>] op=RelOp() [<WS>] e2=CExpression() ]
  { 
    if (op == null) 
      return e1;
    else switch (op.kind) {
      case OP_EQ:  return new Expression.CompareEqBuilder(e1, e2);
      case OP_NE:  return new Expression.CompareNeBuilder(e1, e2);
      case OP_GT:  return new Expression.CompareGtBuilder(e1, e2);
      case OP_GE:  return new Expression.CompareGeBuilder(e1, e2);
      case OP_LE:  return new Expression.CompareLeBuilder(e1, e2);
      case OP_LT:  return new Expression.CompareLtBuilder(e1, e2);
      default:   
        throw new ParseException("internal parser error in CExpression()");
    }
  } 
}

Object BExpression() : {
  Object e1, e2=null;
  Token op=null;
}
{
  e1=CExpression() 
  [ LOOKAHEAD(2) [<WS>] ( op=<OP_AND> | op=<OP_OR> ) [<WS>] 
    e2=BExpression() ]
  { 
    if (op == null) 
      return e1;
    else if (op.kind == OP_AND) 
      return new Expression.AndBuilder(e1, e2);
    else if (op.kind == OP_OR) 
      return new Expression.OrBuilder(e1, e2);
    else 
      throw new ParseException("internal parser error in BExpression()");
  }
}

Object Expression() : {
  Object e=null;
}
{ 
  e=BExpression() { return e; }
}

Object Term() : {
  Object e;
  Token t;
}
{
  ( 
    e=VariableReference() 
    | <LPAREN> e=Expression() <RPAREN>
    | e=QuotedString()
    | e=BracketList() 
    | <NULL>           { e = null; } 
    | <TRUE>           { e = Boolean.TRUE; } 
    | <FALSE>          { e = Boolean.FALSE; }
    | <OP_NOT>e=Term() { e = new Expression.NotBuilder(e); }
    | t=<NUMBER>           
      { try { e = new Long(t.image); } 
        catch (NumberFormatException ex) { e=null; } }
    | <OP_MINUS>t=<NUMBER> 
      { try { long l = Long.parseLong(t.image); e = new Long(-l); }
        catch (NumberFormatException ex) { e=null; } }
  ) 
  { return e; }
}

  
// State information: assumes DEFAULT; returns in DEFAULT
void WMContent(ParserBlockBuilder b) : {
  Token t;
  Object o;
}
{
  ( t=<STUFF>       { b.addElement(t.image); }
    | t=<QCHAR>     { b.addElement(t.image.substring(1)); b.markLiteral(); }
    | t=<SLASH>     { b.addElement(t.image); }
    | <POUND> { SetState(WM); } 
          t=<WORD> [ <WS> ] o=parse_directive(t.image) 
          { b.eatTrailingWsNl(); b.addElement(o); }
    | LOOKAHEAD(<DOLLAR>) 
          { SetState(WM); } 
          o=VariableReference() 
          { b.addElement(o); SetState(DEFAULT); }
  ) [ <COMMENT> { b.eatTrailingWsNl(); } ]
}

void LiteralWMContent(ParserBlockBuilder b) : {
  Token t;
}
{
  ( 
    t=<QCHAR> { b.addElement(t.image.substring(1)); }
    | ( t=<STUFF> | t=<SLASH> | t=<POUND> | t=<DOLLAR> | t=<COMMENT> )
      { b.addElement(t.image); }
  )
}

// State: Assumes WM
void SubdirectiveStart() : {
}
{ 
  OptionalWsNl() <POUND> <WORD> [ <WS> ] 
}

BlockBuilder LiteralBlock() : {
  ParserBlockBuilder block = new ParserBlockBuilder();
  Token t;
}
{
  ( 
    LOOKAHEAD(<LBRACE>) 
    ( <LBRACE>    
      ( LiteralWMContent(block) 
        | ( t=<BEGIN> | t=<END> )     { block.addElement(t.image); }
      ) * 
      <RBRACE> )
  | ( [ <BEGIN> ] 
      ( LiteralWMContent(block)
        | ( t=<LBRACE> | t=<RBRACE> ) { block.addElement(t.image); } 
      ) * 
      <END> )
  )
  { return block; }
}


BlockBuilder Block() : {
  ParserBlockBuilder block = new ParserBlockBuilder();
  Token t;
}
{ 
  ( 
    LOOKAHEAD(<LBRACE>) 
    ( <LBRACE> 
      ( WMContent(block) 
        | (t=<BEGIN> | t=<END>)     { block.addElement(t.image); }
      ) * <RBRACE> { block.eatTrailingWs(); } )
  | ( [ <BEGIN> ] 
      ( WMContent(block) 
        | (t=<LBRACE> | t=<RBRACE>) { block.addElement(t.image); }
      ) * <END> { block.eatTrailingWs(); } )
  )
  { return block; }
}

BlockBuilder WMDocument() : {
  ParserBlockBuilder block = new ParserBlockBuilder();
  Token t;
}
{
  ( 
    ( WMContent(block)
      | (t=<BEGIN> | t=<END> | t=<LBRACE> | t=<RBRACE>)
        { block.addElement(t.image); }
    )
  ) * <EOF> 
  { return block; }
}

